* TODO main [0/0]

** TODO code blocks [0/2]

- [ ] Implement some rst source code directives

  - [ ] ~:linenothreshold: 5~
  - [ ] ~:emphasize-lines:~ line numbers (comma separated numbers)
    Emphasize particular lines of the code block. Alternatively I can
    expand callout mechanism.
  - [ ] Analog to ~:pyobject:~ - use tree-sitter to parse target source
    file and retrieve all entries. ~:codeobject:~ syntax can use
    tree-sitter query format.
  - [ ] ~:start-after:~ and ~:end-before:~ for including delimited section
    of the file.
- [ ] Per-subtree code block sessions. Option to implicitly group all code
  blocks in one subtree into single session.


* TODO parsing [0/6]

- [ ] Handle single quotes for word end in case of ~peoples'~
- [ ] Super/subscript in text ~1.28 x R_{sun}.~
- [ ] Allow line continuation on single-line commands and headers for
  multiline commands, so I could write

  #+begin_example org
    ,#+begin-src c++ --include="some-long-path.hpp" \
      additional arguments to body - still parsed as \
      header

      int main() {
        puts("Actua code");
      }
    ,#+end-src
  #+end_example
- [ ]  Some properties can be placed /after/ element
  #+begin_example
    | 2009 | 901 | 902 | 903 |
    #+TBLFM: @<$<..@>$> = remote(FOO, @$#$@#)
  #+end_example
- [ ] 'Strict compatibility' mode - right now I don't particularly pay much
  attention to keeping fully compatible with default org-mode
  implementation, but this is still an important thing to consider,
  especially for more subtle things like dashes in ~#+begin-src~ (I can
  introduce 'medium compatibility' mode, which will only point out things
  like that.)
- [ ] Handle different formatting arrangements  for logbook entries - I use
  a customized  hook which might  be different from  other implementations.
  Ideally  this part  should be  user-configurable, but  right now  I'm not
  really sure how it should be implemented.

** TODO Command-line tools and integrations [0/3]

- [ ] Implement IDE helpers that would allow to take arbitrary piece of
  org-mode code, reformat it (basically pretty-printer) to particular width
  and paste back. Use it for comment wrapping.
- [ ] Debug document processing - lexing, parsing, semorg conversion. Make
  ~treeRepr()~ and related procs accessible from the CLI interface.
- [ ] Debug nested lexing - for tokens that have to be repeatedly lexed,
  allow to drill down until element has been fully processed. This can also
  be used for additional testing.

** TODO links [/]

- Right now ~[[(callout-name)]]~ only support positions in code that were
  explicitly annotated. If I integrate tooling with tree-sitter I can also
  link to /entries in code/, like ~[[(IR)]]~. I have code that declares
  this field/variable/procedure, and then I write subsequent explanations
  for it. Linking elements in code to the explanataion, or linking
  explanation back to code. This feauture can be seen as a scaled-down
  version of the ~[[code:~ link - it does not have to be extremely precise
  and rely on the parsed code. Maybe simple token search in the closes code
  block would be sufficient, especially considering that code block
  sometimes contain invalid elements, pseudocode etc.

  #+begin_src c
  /* CPU state */
  typedef struct {
      uint16_t IR;        /* internal instruction register */
      uint16_t PC;        /* internal program counter register */
      uint16_t AD;        /* ADL/ADH internal register */
  #+end_src

** TODO C API wrappers [/]

** TODO Documentation [0/2]

- [ ] Example of parse tree (both semorg and org-node)
  - [ ] Required positions and kinds for all AST subnodes (e.g. list item
    contains seven subnodes, but it is quite easy to mess this up). Getter
    and setter procedures for ~link.description()~ should be documented as
    well.
- [ ] Cheat-sheet with grammar elements

** TODO Other

- [ ] Per-cell wrapper for table exports. This might already be possible
  with table formulas. I want to wrap each cell with something like
  ~src_nim{<original source>}~. This is useful for two-column tables with
  source code + explanation on the right side.
  - With ~#+cell~ it is possible to easily have two-three line examples
    without requiring brain surgery after.
  - Though it would complicate parsing, but in general I can just get
    content of the cell itself and wrap it verbatim. Since I try really
    hard to never loose information about element being parsed, I can just
    copy slice into non-leaf nodes as well.
